<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dhtt_base: dhtt_utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">dhtt_base<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dhtt_utils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdhtt__utils_1_1PredCon.html">PredCon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac80abfc51c1ebf95430e16497c968902"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structdhtt__utils_1_1PredCon.html">dhtt_utils::PredCon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a></td></tr>
<tr class="separator:ac80abfc51c1ebf95430e16497c968902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d988440a8a29195c3e457a8b91e9ca0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structdhtt__utils_1_1VectorResources.html">dhtt_utils::VectorResources</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a6d988440a8a29195c3e457a8b91e9ca0">VectorResources</a></td></tr>
<tr class="separator:a6d988440a8a29195c3e457a8b91e9ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a878516bcfba0feba8a6ecae633845f99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a878516bcfba0feba8a6ecae633845f99">logical_operators</a> { <a class="el" href="namespacedhtt__utils.html#a878516bcfba0feba8a6ecae633845f99a1737f886c4ec745728e73a0ef00c98ca">LOGICAL_AND</a> = 1
, <a class="el" href="namespacedhtt__utils.html#a878516bcfba0feba8a6ecae633845f99ac6068e77d8f6eb09e76f5e98ef8eb5e3">LOGICAL_OR</a> = 2
, <a class="el" href="namespacedhtt__utils.html#a878516bcfba0feba8a6ecae633845f99a3930bc6e00cd8c0464e8c15710a8b242">LOGICAL_OTHER</a> = 3
 }</td></tr>
<tr class="separator:a878516bcfba0feba8a6ecae633845f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad4db3bb88da43565a300d3f1b2b53477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ad4db3bb88da43565a300d3f1b2b53477">predicate_partial_equals</a> (dhtt_msgs::msg::Pair lhs, dhtt_msgs::msg::Pair rhs)</td></tr>
<tr class="memdesc:ad4db3bb88da43565a300d3f1b2b53477"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for find_partial_predicate  <a href="namespacedhtt__utils.html#ad4db3bb88da43565a300d3f1b2b53477">More...</a><br /></td></tr>
<tr class="separator:ad4db3bb88da43565a300d3f1b2b53477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef94d527d6554aa8ee6f5921319fd3cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#aef94d527d6554aa8ee6f5921319fd3cc">predicate_equals</a> (const dhtt_msgs::msg::Pair &amp;lhs, const dhtt_msgs::msg::Pair &amp;rhs)</td></tr>
<tr class="memdesc:aef94d527d6554aa8ee6f5921319fd3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality function for predicates  <a href="namespacedhtt__utils.html#aef94d527d6554aa8ee6f5921319fd3cc">More...</a><br /></td></tr>
<tr class="separator:aef94d527d6554aa8ee6f5921319fd3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2e055a2ef2b11e27737dafc44a8e19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a5e2e055a2ef2b11e27737dafc44a8e19">compare_predicates</a> (const dhtt_msgs::msg::Pair &amp;lhs, const dhtt_msgs::msg::Pair &amp;rhs)</td></tr>
<tr class="memdesc:a5e2e055a2ef2b11e27737dafc44a8e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison function for standard library sets  <a href="namespacedhtt__utils.html#a5e2e055a2ef2b11e27737dafc44a8e19">More...</a><br /></td></tr>
<tr class="separator:a5e2e055a2ef2b11e27737dafc44a8e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c3fee03b148db123bae87a1cf6e63"><td class="memItemLeft" align="right" valign="top">dhtt_msgs::msg::Pair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ae58c3fee03b148db123bae87a1cf6e63">predicate_copy</a> (const dhtt_msgs::msg::Pair &amp;msg)</td></tr>
<tr class="memdesc:ae58c3fee03b148db123bae87a1cf6e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of a predicate.  <a href="namespacedhtt__utils.html#ae58c3fee03b148db123bae87a1cf6e63">More...</a><br /></td></tr>
<tr class="separator:ae58c3fee03b148db123bae87a1cf6e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa904de9daac68b7b1481f5d4d3007f66"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#aa904de9daac68b7b1481f5d4d3007f66">conjunction_copy</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;msg)</td></tr>
<tr class="memdesc:aa904de9daac68b7b1481f5d4d3007f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of a conjunction of predicates.  <a href="namespacedhtt__utils.html#aa904de9daac68b7b1481f5d4d3007f66">More...</a><br /></td></tr>
<tr class="separator:aa904de9daac68b7b1481f5d4d3007f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e19ee406f29d91d050a120242157b3d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a4e19ee406f29d91d050a120242157b3d">to_string</a> (std::shared_ptr&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &gt; pred)</td></tr>
<tr class="separator:a4e19ee406f29d91d050a120242157b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e385c4e3f823beb0a0bf4336004312d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a5e385c4e3f823beb0a0bf4336004312d">to_string</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;pred)</td></tr>
<tr class="separator:a5e385c4e3f823beb0a0bf4336004312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2943298cb7840480260660b92e8048c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ad2943298cb7840480260660b92e8048c">convert_to_struct</a> (std::string to_convert)</td></tr>
<tr class="separator:ad2943298cb7840480260660b92e8048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9df4020ee49c30414963fd12962c958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ae9df4020ee49c30414963fd12962c958">remove_predicate_duplicates</a> (<a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;msg)</td></tr>
<tr class="memdesc:ae9df4020ee49c30414963fd12962c958"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes any duplicate predicates from the given predicate conjunction  <a href="namespacedhtt__utils.html#ae9df4020ee49c30414963fd12962c958">More...</a><br /></td></tr>
<tr class="separator:ae9df4020ee49c30414963fd12962c958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4468f5c02369f0f87d764f15cd5cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a3d4468f5c02369f0f87d764f15cd5cdb">remove_predicate_partial_duplicates</a> (<a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;msg)</td></tr>
<tr class="memdesc:a3d4468f5c02369f0f87d764f15cd5cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes duplicates of the same information changing in the temporall reverse order  <a href="namespacedhtt__utils.html#a3d4468f5c02369f0f87d764f15cd5cdb">More...</a><br /></td></tr>
<tr class="separator:a3d4468f5c02369f0f87d764f15cd5cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93346a4642729dfac216e2728673896d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a93346a4642729dfac216e2728673896d">violates_predicates</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;postconditions, const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;preconditions)</td></tr>
<tr class="memdesc:a93346a4642729dfac216e2728673896d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the execution of given postconditions would violate the given preconditions  <a href="namespacedhtt__utils.html#a93346a4642729dfac216e2728673896d">More...</a><br /></td></tr>
<tr class="separator:a93346a4642729dfac216e2728673896d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbc46b79df1b863a6f027da7706b04e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a2cbc46b79df1b863a6f027da7706b04e">contains_contradiction</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;to_check)</td></tr>
<tr class="memdesc:a2cbc46b79df1b863a6f027da7706b04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks given predicate list for internal contradictions  <a href="namespacedhtt__utils.html#a2cbc46b79df1b863a6f027da7706b04e">More...</a><br /></td></tr>
<tr class="separator:a2cbc46b79df1b863a6f027da7706b04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a009cad25e2ee0b7220767fa3c6d5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a3a009cad25e2ee0b7220767fa3c6d5fe">flatten_predicates</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;msg)</td></tr>
<tr class="memdesc:a3a009cad25e2ee0b7220767fa3c6d5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">flattens given predicate conjunction as much as possible  <a href="namespacedhtt__utils.html#a3a009cad25e2ee0b7220767fa3c6d5fe">More...</a><br /></td></tr>
<tr class="separator:a3a009cad25e2ee0b7220767fa3c6d5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e69ab00d21500f9ca3631771838ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a9f6e69ab00d21500f9ca3631771838ec">append_predicate_conjunction</a> (<a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;to, const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> from)</td></tr>
<tr class="memdesc:a9f6e69ab00d21500f9ca3631771838ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines two predicate conjunctions  <a href="namespacedhtt__utils.html#a9f6e69ab00d21500f9ca3631771838ec">More...</a><br /></td></tr>
<tr class="separator:a9f6e69ab00d21500f9ca3631771838ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1332db8647a55ab96829cafda867e0c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a1332db8647a55ab96829cafda867e0c9">combine_predicates</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;l_pred, const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;r_pred)</td></tr>
<tr class="memdesc:a1332db8647a55ab96829cafda867e0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines two given lists of predicates  <a href="namespacedhtt__utils.html#a1332db8647a55ab96829cafda867e0c9">More...</a><br /></td></tr>
<tr class="separator:a1332db8647a55ab96829cafda867e0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2ec4312260dc4291b43440d801c19"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">dhtt_utils::PredicateConjunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#aafc2ec4312260dc4291b43440d801c19">negate_predicates</a> (const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;to_negate)</td></tr>
<tr class="memdesc:aafc2ec4312260dc4291b43440d801c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively negate the predicates of the given predicate conjunction  <a href="namespacedhtt__utils.html#aafc2ec4312260dc4291b43440d801c19">More...</a><br /></td></tr>
<tr class="separator:aafc2ec4312260dc4291b43440d801c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bf8c57486300111c7f6726bf21bd76"><td class="memItemLeft" align="right" valign="top">std::vector&lt; dhtt_msgs::msg::Pair &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ab2bf8c57486300111c7f6726bf21bd76">find_partial_predicate</a> (std::vector&lt; dhtt_msgs::msg::Pair &gt; to_search, dhtt_msgs::msg::Pair to_find)</td></tr>
<tr class="memdesc:ab2bf8c57486300111c7f6726bf21bd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a given key value pair in the given vector of predicates  <a href="namespacedhtt__utils.html#ab2bf8c57486300111c7f6726bf21bd76">More...</a><br /></td></tr>
<tr class="separator:ab2bf8c57486300111c7f6726bf21bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b765d33eaa4d1699a3dc0494e2877b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; dhtt_msgs::msg::Pair &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#af2b765d33eaa4d1699a3dc0494e2877b">find_predicate</a> (std::vector&lt; dhtt_msgs::msg::Pair &gt; &amp;to_search, dhtt_msgs::msg::Pair to_find)</td></tr>
<tr class="memdesc:af2b765d33eaa4d1699a3dc0494e2877b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a given predicate in a given vector of predicates  <a href="namespacedhtt__utils.html#af2b765d33eaa4d1699a3dc0494e2877b">More...</a><br /></td></tr>
<tr class="separator:af2b765d33eaa4d1699a3dc0494e2877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6681546e5e1a89c201882d2ac3a626eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a6681546e5e1a89c201882d2ac3a626eb">remove_partial_dependencies</a> (const std::vector&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &gt; post, const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;pre)</td></tr>
<tr class="memdesc:a6681546e5e1a89c201882d2ac3a626eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes partial temporal dependencies between the given list of postconditions and the given preconditions.  <a href="namespacedhtt__utils.html#a6681546e5e1a89c201882d2ac3a626eb">More...</a><br /></td></tr>
<tr class="separator:a6681546e5e1a89c201882d2ac3a626eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb9bbf6456dcbef69dc065c1ee412c3"><td class="memItemLeft" align="right" valign="top">dhtt_msgs::msg::Resources&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a8bb9bbf6456dcbef69dc065c1ee412c3">vector_to_msg</a> (<a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> data)</td></tr>
<tr class="memdesc:a8bb9bbf6456dcbef69dc065c1ee412c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a dhtt_msgs::msg::Resources object from vectors containing the necessary information  <a href="namespacedhtt__utils.html#a8bb9bbf6456dcbef69dc065c1ee412c3">More...</a><br /></td></tr>
<tr class="separator:a8bb9bbf6456dcbef69dc065c1ee412c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ad751f513e7b91c656460757e0e4c2"><td class="memItemLeft" align="right" valign="top">dhtt_msgs::msg::Resources&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#ad4ad751f513e7b91c656460757e0e4c2">vector_to_msg</a> (std::vector&lt; std::string &gt; names, std::vector&lt; long int &gt; types, std::vector&lt; long int &gt; channels, std::vector&lt; bool &gt; locked, std::vector&lt; long int &gt; owners)</td></tr>
<tr class="memdesc:ad4ad751f513e7b91c656460757e0e4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of vector_to_msg which takes each vector individually as a parameter  <a href="namespacedhtt__utils.html#ad4ad751f513e7b91c656460757e0e4c2">More...</a><br /></td></tr>
<tr class="separator:ad4ad751f513e7b91c656460757e0e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77020d28b2f386f1fa950882e30a0124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a77020d28b2f386f1fa950882e30a0124">msg_to_vector</a> (std::vector&lt; dhtt_msgs::msg::Resource &gt; msgs)</td></tr>
<tr class="memdesc:a77020d28b2f386f1fa950882e30a0124"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> object from a given vector of dhtt_msgs::msg::Resource msgs  <a href="namespacedhtt__utils.html#a77020d28b2f386f1fa950882e30a0124">More...</a><br /></td></tr>
<tr class="separator:a77020d28b2f386f1fa950882e30a0124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfda421111e0ec5acd7831c0c91c6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedhtt__utils.html#a1bfda421111e0ec5acd7831c0c91c6ca">msg_to_vector</a> (dhtt_msgs::msg::Resources msg)</td></tr>
<tr class="memdesc:a1bfda421111e0ec5acd7831c0c91c6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> object from a given dhtt_msgs::msg::Resources msg  <a href="namespacedhtt__utils.html#a1bfda421111e0ec5acd7831c0c91c6ca">More...</a><br /></td></tr>
<tr class="separator:a1bfda421111e0ec5acd7831c0c91c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac80abfc51c1ebf95430e16497c968902" name="ac80abfc51c1ebf95430e16497c968902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80abfc51c1ebf95430e16497c968902">&#9670;&#160;</a></span>PredicateConjunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdhtt__utils_1_1PredCon.html">dhtt_utils::PredCon</a> <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">dhtt_utils::PredicateConjunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d988440a8a29195c3e457a8b91e9ca0" name="a6d988440a8a29195c3e457a8b91e9ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d988440a8a29195c3e457a8b91e9ca0">&#9670;&#160;</a></span>VectorResources</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdhtt__utils_1_1VectorResources.html">dhtt_utils::VectorResources</a> <a class="el" href="structdhtt__utils_1_1VectorResources.html">dhtt_utils::VectorResources</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a878516bcfba0feba8a6ecae633845f99" name="a878516bcfba0feba8a6ecae633845f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878516bcfba0feba8a6ecae633845f99">&#9670;&#160;</a></span>logical_operators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedhtt__utils.html#a878516bcfba0feba8a6ecae633845f99">dhtt_utils::logical_operators</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a878516bcfba0feba8a6ecae633845f99a1737f886c4ec745728e73a0ef00c98ca" name="a878516bcfba0feba8a6ecae633845f99a1737f886c4ec745728e73a0ef00c98ca"></a>LOGICAL_AND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a878516bcfba0feba8a6ecae633845f99ac6068e77d8f6eb09e76f5e98ef8eb5e3" name="a878516bcfba0feba8a6ecae633845f99ac6068e77d8f6eb09e76f5e98ef8eb5e3"></a>LOGICAL_OR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a878516bcfba0feba8a6ecae633845f99a3930bc6e00cd8c0464e8c15710a8b242" name="a878516bcfba0feba8a6ecae633845f99a3930bc6e00cd8c0464e8c15710a8b242"></a>LOGICAL_OTHER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f6e69ab00d21500f9ca3631771838ec" name="a9f6e69ab00d21500f9ca3631771838ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6e69ab00d21500f9ca3631771838ec">&#9670;&#160;</a></span>append_predicate_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dhtt_utils::append_predicate_conjunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>combines two predicate conjunctions </p>
<p >This function does not check for duplicate predicates after appending to the to list. If that is the desired behavior then explicitly run remove_predicate_duplicates after this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>will have the other parameter appended to it </td></tr>
    <tr><td class="paramname">from</td><td>will be appended to to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a1332db8647a55ab96829cafda867e0c9" name="a1332db8647a55ab96829cafda867e0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1332db8647a55ab96829cafda867e0c9">&#9670;&#160;</a></span>combine_predicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> dhtt_utils::combine_predicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>l_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>r_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>combines two given lists of predicates </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_pred</td><td>first Predicate Conjunctions </td></tr>
    <tr><td class="paramname">r_pred</td><td>second Predicate Conjunctions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flattened list of predicates combined into a Predicate Conjunctions </dd></dl>

</div>
</div>
<a id="a5e2e055a2ef2b11e27737dafc44a8e19" name="a5e2e055a2ef2b11e27737dafc44a8e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2e055a2ef2b11e27737dafc44a8e19">&#9670;&#160;</a></span>compare_predicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dhtt_utils::compare_predicates </td>
          <td>(</td>
          <td class="paramtype">const dhtt_msgs::msg::Pair &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dhtt_msgs::msg::Pair &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison function for standard library sets </p>

</div>
</div>
<a id="aa904de9daac68b7b1481f5d4d3007f66" name="aa904de9daac68b7b1481f5d4d3007f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa904de9daac68b7b1481f5d4d3007f66">&#9670;&#160;</a></span>conjunction_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &gt; dhtt_utils::conjunction_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of a conjunction of predicates. </p>
<p >Utilizes the recursive definition of a predicate conjunction, and maintains all properties of the initial msg (including order).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>predicate conjunction to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deep copy of predicate conjunction </dd></dl>

</div>
</div>
<a id="a2cbc46b79df1b863a6f027da7706b04e" name="a2cbc46b79df1b863a6f027da7706b04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbc46b79df1b863a6f027da7706b04e">&#9670;&#160;</a></span>contains_contradiction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dhtt_utils::contains_contradiction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>to_check</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks given predicate list for internal contradictions </p>
<p >An internal contradiction in this context involves for instance having the following predicate relationship ( p /\ !p ) or ( p \/ !p ). If a predicate is meant to realize both possible values we consider that a contradiction for now. However, logically this will not cover every possible contradiction that could occur in predicate relationships as testing if a predicate conjunction is logical is NP-Hard (SAT).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_check</td><td>Predicate Conjunction to check for contradictions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a contradiction is found, false otherwise. </dd></dl>

</div>
</div>
<a id="ad2943298cb7840480260660b92e8048c" name="ad2943298cb7840480260660b92e8048c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2943298cb7840480260660b92e8048c">&#9670;&#160;</a></span>convert_to_struct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> dhtt_utils::convert_to_struct </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>to_convert</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2bf8c57486300111c7f6726bf21bd76" name="ab2bf8c57486300111c7f6726bf21bd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bf8c57486300111c7f6726bf21bd76">&#9670;&#160;</a></span>find_partial_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; dhtt_msgs::msg::Pair &gt;::iterator dhtt_utils::find_partial_predicate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; dhtt_msgs::msg::Pair &gt;&#160;</td>
          <td class="paramname"><em>to_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dhtt_msgs::msg::Pair&#160;</td>
          <td class="paramname"><em>to_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a given key value pair in the given vector of predicates </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found predicate, or to_search.end() if not found </dd></dl>

</div>
</div>
<a id="af2b765d33eaa4d1699a3dc0494e2877b" name="af2b765d33eaa4d1699a3dc0494e2877b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b765d33eaa4d1699a3dc0494e2877b">&#9670;&#160;</a></span>find_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; dhtt_msgs::msg::Pair &gt;::iterator dhtt_utils::find_predicate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; dhtt_msgs::msg::Pair &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dhtt_msgs::msg::Pair&#160;</td>
          <td class="paramname"><em>to_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a given predicate in a given vector of predicates </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to found predicate, or to_search.end() if not found </dd></dl>

</div>
</div>
<a id="a3a009cad25e2ee0b7220767fa3c6d5fe" name="a3a009cad25e2ee0b7220767fa3c6d5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a009cad25e2ee0b7220767fa3c6d5fe">&#9670;&#160;</a></span>flatten_predicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> dhtt_utils::flatten_predicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flattens given predicate conjunction as much as possible </p>
<p >Predicates can only be flattened if they share the same logical operator otherwise distributive properties have to be used and the list gets more confusing. So those are the only ones that are flattened. We are not considering cases where there are multiple levels of predicate conjunctions with the same logical operator. In those cases, run this function multiple times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>to flatten</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deep copy of the message but flattened as much as possible </dd></dl>

</div>
</div>
<a id="a1bfda421111e0ec5acd7831c0c91c6ca" name="a1bfda421111e0ec5acd7831c0c91c6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfda421111e0ec5acd7831c0c91c6ca">&#9670;&#160;</a></span>msg_to_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> dhtt_utils::msg_to_vector </td>
          <td>(</td>
          <td class="paramtype">dhtt_msgs::msg::Resources&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a <a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> object from a given dhtt_msgs::msg::Resources msg </p>
<p >This is an overload of msg_to_vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>object to transform for list representation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> struct with equivalent information to msg </dd></dl>

</div>
</div>
<a id="a77020d28b2f386f1fa950882e30a0124" name="a77020d28b2f386f1fa950882e30a0124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77020d28b2f386f1fa950882e30a0124">&#9670;&#160;</a></span>msg_to_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> dhtt_utils::msg_to_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; dhtt_msgs::msg::Resource &gt;&#160;</td>
          <td class="paramname"><em>msgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a <a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> object from a given vector of dhtt_msgs::msg::Resource msgs </p>
<p >This transformation is useful for pushing resources to the param server. Will put default values for resources with empty values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgs</td><td>object to transform for list representation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> struct with equivalent information to msg </dd></dl>

</div>
</div>
<a id="aafc2ec4312260dc4291b43440d801c19" name="aafc2ec4312260dc4291b43440d801c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc2ec4312260dc4291b43440d801c19">&#9670;&#160;</a></span>negate_predicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">dhtt_utils::PredicateConjunction</a> &gt; dhtt_utils::negate_predicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>to_negate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively negate the predicates of the given predicate conjunction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_negate</td><td>Predicate Conjunction which is to be negated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverse copy of to_negate </dd></dl>

</div>
</div>
<a id="ae58c3fee03b148db123bae87a1cf6e63" name="ae58c3fee03b148db123bae87a1cf6e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58c3fee03b148db123bae87a1cf6e63">&#9670;&#160;</a></span>predicate_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dhtt_msgs::msg::Pair dhtt_utils::predicate_copy </td>
          <td>(</td>
          <td class="paramtype">const dhtt_msgs::msg::Pair &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>predicate to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deep copy of predicate </dd></dl>

</div>
</div>
<a id="aef94d527d6554aa8ee6f5921319fd3cc" name="aef94d527d6554aa8ee6f5921319fd3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef94d527d6554aa8ee6f5921319fd3cc">&#9670;&#160;</a></span>predicate_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dhtt_utils::predicate_equals </td>
          <td>(</td>
          <td class="paramtype">const dhtt_msgs::msg::Pair &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dhtt_msgs::msg::Pair &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equality function for predicates </p>
<dl class="section return"><dt>Returns</dt><dd>True if predicates are equal, False otherwise </dd></dl>

</div>
</div>
<a id="ad4db3bb88da43565a300d3f1b2b53477" name="ad4db3bb88da43565a300d3f1b2b53477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4db3bb88da43565a300d3f1b2b53477">&#9670;&#160;</a></span>predicate_partial_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dhtt_utils::predicate_partial_equals </td>
          <td>(</td>
          <td class="paramtype">dhtt_msgs::msg::Pair&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dhtt_msgs::msg::Pair&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper for find_partial_predicate </p>
<p >This is the same as predicate_equals except that the negation member of the Pair message is not checked</p>
<dl class="section return"><dt>Returns</dt><dd>True if predicates share key and value, false otherwise </dd></dl>

</div>
</div>
<a id="a6681546e5e1a89c201882d2ac3a626eb" name="a6681546e5e1a89c201882d2ac3a626eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6681546e5e1a89c201882d2ac3a626eb">&#9670;&#160;</a></span>remove_partial_dependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> dhtt_utils::remove_partial_dependencies </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &gt;&#160;</td>
          <td class="paramname"><em>post</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>pre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes partial temporal dependencies between the given list of postconditions and the given preconditions. </p>
<p >Searches the list of preconditions for the given postconditions. If any are found then they are not included in the returned set of preconditions. Currently only works on preconditions that are and'ed together because if they are or'ed instead then there is no partial dependency. For that same reason this check is not recursive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">post</td><td>vector of predicate conjunctions representing the sum total of the postconditions to check for </td></tr>
    <tr><td class="paramname">pre</td><td>predicate conjunction of preconditions to check against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new predicate conjunction of only the preconditions which were not found in the postconditions </dd></dl>

</div>
</div>
<a id="ae9df4020ee49c30414963fd12962c958" name="ae9df4020ee49c30414963fd12962c958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9df4020ee49c30414963fd12962c958">&#9670;&#160;</a></span>remove_predicate_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dhtt_utils::remove_predicate_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes any duplicate predicates from the given predicate conjunction </p>
<p >Duplicate predicates with the same logical operator represent only themselves ( a and a = a ) therefore removing them is free and should save some work when processing the predicates as it will keep the lists shorter. Hopefully it is less work to maintain this property then it is to just leave duplicates in. Either way this is cleaner for the user when inspecting predicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>where the duplicates will be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a3d4468f5c02369f0f87d764f15cd5cdb" name="a3d4468f5c02369f0f87d764f15cd5cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4468f5c02369f0f87d764f15cd5cdb">&#9670;&#160;</a></span>remove_predicate_partial_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dhtt_utils::remove_predicate_partial_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes duplicates of the same information changing in the temporall reverse order </p>
<p >Useful for instance in a THEN node where a single predicate's status may be changing. This ensures that only the last state is remembered as a postcondition of that behavior</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>where the duplicates will be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a5e385c4e3f823beb0a0bf4336004312d" name="a5e385c4e3f823beb0a0bf4336004312d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e385c4e3f823beb0a0bf4336004312d">&#9670;&#160;</a></span>to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dhtt_utils::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e19ee406f29d91d050a120242157b3d" name="a4e19ee406f29d91d050a120242157b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e19ee406f29d91d050a120242157b3d">&#9670;&#160;</a></span>to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dhtt_utils::to_string </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &gt;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4ad751f513e7b91c656460757e0e4c2" name="ad4ad751f513e7b91c656460757e0e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ad751f513e7b91c656460757e0e4c2">&#9670;&#160;</a></span>vector_to_msg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dhtt_msgs::msg::Resources dhtt_utils::vector_to_msg </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long int &gt;&#160;</td>
          <td class="paramname"><em>owners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of vector_to_msg which takes each vector individually as a parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>vector of strings </td></tr>
    <tr><td class="paramname">types</td><td>vector of types represented as integers </td></tr>
    <tr><td class="paramname">channels</td><td>vector of resource channels </td></tr>
    <tr><td class="paramname">locks</td><td>vector of booleans representing locked or unlocked </td></tr>
    <tr><td class="paramname">owners</td><td>vector of each resource's number of owners</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>msg representation of above information </dd></dl>

</div>
</div>
<a id="a8bb9bbf6456dcbef69dc065c1ee412c3" name="a8bb9bbf6456dcbef69dc065c1ee412c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb9bbf6456dcbef69dc065c1ee412c3">&#9670;&#160;</a></span>vector_to_msg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dhtt_msgs::msg::Resources dhtt_utils::vector_to_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a dhtt_msgs::msg::Resources object from vectors containing the necessary information </p>
<p >Vectors should all be the same size and the information for a single resource should correspond to a single index across all of them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><a class="el" href="structdhtt__utils_1_1VectorResources.html">VectorResources</a> struct containing all of the information to transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>msg which is equivalent to the data </dd></dl>

</div>
</div>
<a id="a93346a4642729dfac216e2728673896d" name="a93346a4642729dfac216e2728673896d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93346a4642729dfac216e2728673896d">&#9670;&#160;</a></span>violates_predicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dhtt_utils::violates_predicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>postconditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedhtt__utils.html#ac80abfc51c1ebf95430e16497c968902">PredicateConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>preconditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if the execution of given postconditions would violate the given preconditions </p>
<p >This check essentially set's all values of the given postconditions to true and then assumes all others are true as well. So any negations not in the postconditions list will evaluate to false etc. and whatever is given in the postconditions list is considered true (negations will also evaluate to true). Therefore, we will just evaluate the whole boolean statement recursively to generate and return the negation of truth value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">postconditions</td><td>Predicate Conjunction of the postcondition list </td></tr>
    <tr><td class="paramname">preconditions</td><td>Predicate Conjunction of the preconditions list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the postconditions would violate the preconditions (on their own), false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
